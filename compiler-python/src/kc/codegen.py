"""
LLVM IR code generation for k-language.

This module generates LLVM IR code from typed k programs,
following the runtime ABI described in Chapters 6-8 of the book.
"""

from typing import Dict, List, Set, Optional, Any
from .nodes import *
from .types import TypedProgram, TypeContext, CanonicalType


class CodeGenerator:
    """LLVM IR code generator for k-language."""
    
    def __init__(self):
        self.output: List[str] = []
        self.indent_level = 0
        self.label_counter = 0
        self.temp_counter = 0
    
    def _emit(self, line: str) -> None:
        """Emit a line of LLVM IR."""
        indent = "  " * self.indent_level
        self.output.append(f"{indent}{line}")
    
    def _new_label(self, prefix: str = "label") -> str:
        """Generate a new unique label."""
        self.label_counter += 1
        return f"{prefix}_{self.label_counter}"
    
    def _new_temp(self, prefix: str = "tmp") -> str:
        """Generate a new temporary variable."""
        self.temp_counter += 1
        return f"%{prefix}_{self.temp_counter}"
    
    def generate(self, typed_program: TypedProgram, optimize: bool = True) -> str:
        """Generate LLVM IR for the entire program."""
        self.output = []
        
        # Generate header and runtime declarations
        self._generate_header()
        self._generate_runtime_declarations()
        
        # Generate type metadata tables
        self._generate_type_tables(typed_program.type_context)
        
        # Generate function definitions
        for func_name, func_info in typed_program.typed_functions.items():
            self._generate_function(func_name, func_info)
        
        # Generate main function
        self._generate_main_function(typed_program)
        
        return "\n".join(self.output)
    
    def _generate_header(self) -> None:
        """Generate LLVM IR header."""
        self._emit("; k-language compiled program")
        self._emit("; Generated by k-compiler-python")
        self._emit("")
        self._emit("; Target data layout")
        self._emit('target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"')
        self._emit('target triple = "x86_64-unknown-linux-gnu"')
        self._emit("")
    
    def _generate_runtime_declarations(self) -> None:
        """Generate declarations for runtime functions."""
        self._emit("; Runtime function declarations")
        self._emit("")
        
        # Value structure: { i32 type_id, i8* data }
        self._emit("%Value = type { i32, i8* }")
        self._emit("")
        
        # Runtime functions following the ABI from Chapter 7
        self._emit("declare %Value* @k_make_unit()")
        self._emit("declare %Value* @k_make_product(i32 %field_count, ...)")
        self._emit("declare %Value* @k_make_union(i32 %type_id, i32 %variant_index, %Value* %payload)")
        self._emit("declare %Value* @k_project(%Value* %value, i32 %field_index)")
        self._emit("declare i32 @k_get_variant(%Value* %value)")
        self._emit("declare %Value* @k_get_union_payload(%Value* %value)")
        self._emit("declare i1 @k_has_type(%Value* %value, i32 %type_id)")
        self._emit("")
        
        # Memory management
        self._emit("declare void @k_retain(%Value* %value)")
        self._emit("declare void @k_release(%Value* %value)")
        self._emit("")
    
    def _generate_type_tables(self, context: TypeContext) -> None:
        """Generate type metadata tables."""
        self._emit("; Type metadata tables")
        self._emit("")
        
        for type_id, canonical_type in context.types.items():
            # Convert type_id hash to a numeric constant
            type_numeric_id = abs(hash(type_id)) % (2**31)
            
            if canonical_type.kind == 'product':
                self._emit(f"; Product type {type_id}")
                field_count = len(canonical_type.fields)
                self._emit(f"@type_{type_id}_kind = global i32 0  ; 0 = product")
                self._emit(f"@type_{type_id}_field_count = global i32 {field_count}")
                
                # Field name array (simplified - just indices for now)
                if field_count > 0:
                    field_names = list(canonical_type.fields.keys())
                    for i, field_name in enumerate(field_names):
                        self._emit(f"@type_{type_id}_field_{i}_name = global [%d x i8] c\"{field_name}\\00\"" % (len(field_name) + 1))
            
            elif canonical_type.kind == 'union':
                self._emit(f"; Union type {type_id}")
                variant_count = len(canonical_type.fields)
                self._emit(f"@type_{type_id}_kind = global i32 1  ; 1 = union")
                self._emit(f"@type_{type_id}_variant_count = global i32 {variant_count}")
                
                # Variant name array
                if variant_count > 0:
                    variant_names = list(canonical_type.fields.keys())
                    for i, variant_name in enumerate(variant_names):
                        self._emit(f"@type_{type_id}_variant_{i}_name = global [%d x i8] c\"{variant_name}\\00\"" % (len(variant_name) + 1))
        
        self._emit("")
    
    def _generate_function(self, func_name: str, func_info: Dict[str, Any]) -> None:
        """Generate LLVM IR for a function definition."""
        self._emit(f"; Function: {func_name}")
        self._emit(f"define %Value* @{func_name}(%Value* %input) {{")
        self.indent_level += 1
        
        # Generate code for the function body
        result_temp = self._generate_expression(func_info['expression'])
        
        self._emit(f"ret %Value* {result_temp}")
        
        self.indent_level -= 1
        self._emit("}")
        self._emit("")
    
    def _generate_expression(self, expr: Expression) -> str:
        """Generate LLVM IR for an expression and return the result variable."""
        if isinstance(expr, Projection):
            return self._generate_projection(expr)
        elif isinstance(expr, NameRef):
            return self._generate_name_ref(expr)
        elif isinstance(expr, TypeRestriction):
            return self._generate_type_restriction(expr)
        elif isinstance(expr, Composition):
            return self._generate_composition(expr)
        elif isinstance(expr, Union):
            return self._generate_union(expr)
        elif isinstance(expr, Product):
            return self._generate_product(expr)
        else:
            # Fallback: return unit value
            result_temp = self._new_temp("unit")
            self._emit(f"{result_temp} = call %Value* @k_make_unit()")
            return result_temp
    
    def _generate_projection(self, proj: Projection) -> str:
        """Generate code for field projection .field"""
        result_temp = self._new_temp("proj")
        # For now, assume field index 0 (would need field lookup table)
        self._emit(f"{result_temp} = call %Value* @k_project(%Value* %input, i32 0)")
        return result_temp
    
    def _generate_name_ref(self, name_ref: NameRef) -> str:
        """Generate code for function reference."""
        result_temp = self._new_temp("call")
        self._emit(f"{result_temp} = call %Value* @{name_ref.name}(%Value* %input)")
        return result_temp
    
    def _generate_type_restriction(self, type_rest: TypeRestriction) -> str:
        """Generate code for type restriction $T"""
        # Type restriction acts as identity if input has correct type, undefined otherwise
        result_temp = self._new_temp("type_check")
        
        # For now, simplified - just return input (would need proper type checking)
        self._emit(f"{result_temp} = %Value* %input")
        return result_temp
    
    def _generate_composition(self, comp: Composition) -> str:
        """Generate code for composition (f g h)"""
        if not comp.functions:
            # Empty composition is identity
            return "%input"
        
        # Apply functions left to right
        current_value = "%input"
        for func in comp.functions:
            temp_input = self._new_temp("comp_input")
            self._emit(f"{temp_input} = %Value* {current_value}")
            
            # Temporarily set input for nested expression
            old_input = "%input"
            current_value = self._generate_expression(func)
        
        return current_value
    
    def _generate_union(self, union: Union) -> str:
        """Generate code for union <f, g>"""
        result_temp = self._new_temp("union_result")
        
        # Try each alternative until one succeeds
        # This is simplified - full implementation needs proper error handling
        if union.alternatives:
            return self._generate_expression(union.alternatives[0])
        else:
            # Empty union is always undefined
            self._emit(f"{result_temp} = %Value* null")
            return result_temp
    
    def _generate_product(self, prod: Product) -> str:
        """Generate code for product function {f label1, g label2}"""
        if not prod.components:
            # Empty product function {} - produces unit value regardless of input
            result_temp = self._new_temp("unit")
            self._emit(f"{result_temp} = call %Value* @k_make_unit()")
            return result_temp
        
        # Evaluate each component and combine into product
        component_results = []
        for label, component_expr in prod.components.items():
            component_result = self._generate_expression(component_expr)
            component_results.append(component_result)
        
        # Create product value
        result_temp = self._new_temp("product")
        field_count = len(component_results)
        
        # Generate call to k_make_product with variable arguments
        args_str = ", ".join(f"%Value* {result}" for result in component_results)
        self._emit(f"{result_temp} = call %Value* @k_make_product(i32 {field_count}, {args_str})")
        
        return result_temp
    
    def _generate_main_function(self, typed_program: TypedProgram) -> None:
        """Generate main function that runs the program."""
        self._emit("; Main function")
        self._emit("define i32 @main(i32 %argc, i8** %argv) {")
        self.indent_level += 1
        
        # For now, create a unit input value
        input_temp = self._new_temp("main_input")
        self._emit(f"{input_temp} = call %Value* @k_make_unit()")
        
        # Call the main expression (simplified)
        result_temp = self._new_temp("main_result")
        if isinstance(typed_program.main_expression, NameRef):
            func_name = typed_program.main_expression.name
            self._emit(f"{result_temp} = call %Value* @{func_name}(%Value* {input_temp})")
        else:
            # Generate inline code for main expression
            # This would need the full expression generation context
            self._emit(f"{result_temp} = %Value* {input_temp}")
        
        # Return success
        self._emit("ret i32 0")
        
        self.indent_level -= 1
        self._emit("}")


# Testing function
if __name__ == "__main__":
    from .parser import Parser
    from .types import TypeSystem
    
    # Test code generation
    source = """
    $bool = < {} true, {} false >;
    neg = .x;
    neg
    """
    
    parser = Parser()
    ast = parser.parse(source)
    
    type_system = TypeSystem()
    typed_program = type_system.analyze(ast)
    
    codegen = CodeGenerator()
    llvm_ir = codegen.generate(typed_program)
    
    print("LLVM IR generation complete!")
    print(llvm_ir)